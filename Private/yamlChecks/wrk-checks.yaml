checks:
  - ID: "WRK001"
    Name: "DaemonSets Not Fully Running"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "DaemonSet"
    Severity: "warning"
    Weight: 2
    Description: "Detects DaemonSets that have fewer running pods than desired."
    FailMessage: "DaemonSet is not running on all desired nodes."
    URL: "https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/"
    Recommendation:
      text: "Investigate DaemonSets not fully running. Common causes include taints, node issues, or resource constraints."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Run <code>kubectl describe ds <name> -n <namespace></code> to check for scheduling issues.</li>
            <li>Check node taints and conditions.</li>
            <li>Ensure resource requests are not too high for nodes.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some DaemonSets aren‚Äôt running on all expected nodes."
      - ""
      - "üìå This may be due to taints, resource pressure, or scheduling rules."
      - ""
      - "‚ö†Ô∏è Investigate why the pods aren‚Äôt placed as expected."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)
      
      $daemonsets = if ($KubeData?.DaemonSets) {
        $KubeData.DaemonSets.items
      } else {
        (kubectl get daemonsets -A -o json | ConvertFrom-Json).items
      }
      
      if ($ExcludeNamespaces) {
        $daemonsets = Exclude-Namespaces -items $daemonsets
      }
      
      if ($Namespace) {
        $daemonsets = $daemonsets | Where-Object { $_.metadata.namespace -eq $Namespace }
      }
      
      $daemonsets | Where-Object {
        $_.status.desiredNumberScheduled -ne $_.status.numberReady
      } | ForEach-Object {
        $desired = if ($_.status.desiredNumberScheduled -ne $null) { $_.status.desiredNumberScheduled } else { 0 }
        $ready   = if ($_.status.numberReady -ne $null) { $_.status.numberReady } else { 0 }
        [pscustomobject]@{
          Namespace     = $_.metadata.namespace
          DaemonSet     = $_.metadata.name
          Availability  = "$ready/$desired"
          Message       = "DaemonSet is not running on all desired nodes."
        }
      } | Sort-Object Namespace, DaemonSet
  - ID: "WRK002"
    Name: "Deployment Missing Replicas"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "Deployment"
    Severity: "warning"
    Weight: 3
    Description: "Detects Deployments where the number of available replicas is less than desired."
    FailMessage: "Deployment has fewer available replicas than desired."
    URL: "https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"
    Recommendation:
      text: "Check Deployments that are not meeting their replica count. This may indicate rollout issues or failed pods."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Run <code>kubectl describe deployment <name> -n <namespace></code> to view status.</li>
            <li>Check for failed pods using <code>kubectl get pods -n <namespace></code>.</li>
            <li>Review rollout and events for delays or crashes.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some Deployments aren‚Äôt meeting their desired replica count."
      - ""
      - "üìå This could mean pods are failing, pending, or being slow to start."
      - ""
      - "‚ö†Ô∏è Check pod logs and rollout status."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      $deployments = if ($KubeData?.Deployments) {
        $KubeData.Deployments
      } else {
        (kubectl get deployments -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $deployments = Exclude-Namespaces -items $deployments
      }
      if ($Namespace) {
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $deployments | Where-Object {
        $_.status.availableReplicas -eq $null -or $_.status.availableReplicas -lt $_.spec.replicas
      } | ForEach-Object {
        $available = if ($_.status.availableReplicas -ne $null) { $_.status.availableReplicas } else { 0 }
        [pscustomobject]@{
          Namespace    = $_.metadata.namespace
          Deployment   = $_.metadata.name
          Availability = "$available/$($_.spec.replicas)"
          Message      = "Deployment has fewer available replicas than desired."
        }
      }
  - ID: "WRK003"
    Name: "StatefulSet Incomplete Rollout"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "StatefulSet"
    Severity: "warning"
    Weight: 3
    Description: "Detects StatefulSets where the number of ready replicas is less than the desired count."
    FailMessage: "StatefulSet has fewer ready replicas than desired."
    URL: "https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/"
    Recommendation:
      text: "Investigate StatefulSets with missing ready replicas. This may indicate issues with pod readiness or volume binding."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Run <code>kubectl describe sts name -n namespace</code> to view rollout and events.</li>
            <li>Check pod logs and PersistentVolumeClaim bindings.</li>
            <li>Confirm storage class availability and node scheduling constraints.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some StatefulSets have fewer ready replicas than desired."
      - ""
      - "üìå This could point to pod readiness issues or PVC problems."
      - ""
      - "‚ö†Ô∏è Review logs, events, and volume bindings."
    Script: |
      param(
          [object]$KubeData,
          [string]$Namespace,
          [switch]$ExcludeNamespaces
      )
      
      # ------------------------------------------------------------------
      # Pull StatefulSets
      # ------------------------------------------------------------------
      $statefulsets = if ($KubeData?.StatefulSets) {
          $KubeData.StatefulSets
      } else {
          (kubectl get statefulsets -A -o json | ConvertFrom-Json).items
      }
      
      if ($ExcludeNamespaces) {
          $statefulsets = Exclude-Namespaces -items $statefulsets
      }
      if ($Namespace) {
          $statefulsets = $statefulsets |
              Where-Object { $_.metadata.namespace -eq $Namespace }
      }
      
      # Early-exit if nothing to check
      if (-not $statefulsets -or $statefulsets.Count -eq 0) {
          return
      }
      
      # ------------------------------------------------------------------
      # Emit findings only when readyReplicas < replicas
      # ------------------------------------------------------------------
      $statefulsets |
      Where-Object {
          # Treat missing status.readyReplicas as 0
          $ready   = $_.status.readyReplicas
          $desired = $_.spec.replicas
      
          # If replicas not set, Kubernetes defaults to 1
          if (-not $desired) { $desired = 1 }
      
          ($ready -eq $null) -or ([int]$ready -lt [int]$desired)
      } |
      ForEach-Object {
          $ready   = $_.status.readyReplicas
          $desired = $_.spec.replicas
          if (-not $desired) { $desired = 1 }
          if (-not $ready)   { $ready   = 0 }
      
          [pscustomobject]@{
              Namespace    = $_.metadata.namespace
              StatefulSet  = $_.metadata.name
              Availability = \"$ready/$desired\"
              Message      = \"StatefulSet has fewer ready replicas than desired.\"
          }
      }

  - ID: "WRK004"
    Name: "HPA Misconfiguration or Inactivity"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "HorizontalPodAutoscaler"
    Severity: "warning"
    Weight: 1
    Description: "Checks for HPAs that have missing targets, no metrics, or inactive scaling."
    FailMessage: "HPA is misconfigured, inactive, or not scaling correctly."
    URL: "https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"
    Recommendation:
      text: "Review HorizontalPodAutoscalers with missing targets, no metrics, or disabled scaling."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Check if the target workload exists using <code>kubectl get deploy|sts -n <namespace></code>.</li>
            <li>Use <code>kubectl describe hpa <name> -n <namespace></code> to inspect HPA status and events.</li>
            <li>Ensure metrics-server is running and the target exposes the required metrics.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some HorizontalPodAutoscalers are inactive or misconfigured."
      - ""
      - "üìå Issues include missing metrics, invalid targets, or scaling disabled."
      - ""
      - "‚ö†Ô∏è Check the target object and HPA events."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)
      
      # Get HPAs
      $hpas = if ($KubeData?.HorizontalPodAutoscalers) {
        $KubeData.HorizontalPodAutoscalers
      } else {
        (kubectl get hpa -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $hpas = Exclude-Namespaces -items $hpas
      }
      if ($Namespace) {
        $hpas = $hpas | Where-Object { $_.metadata.namespace -eq $Namespace }
      }
      
      # Get Deployments
      $deployments = if ($KubeData?.Deployments) {
        $KubeData.Deployments
      } else {
        (kubectl get deployments -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $deployments = Exclude-Namespaces -items $deployments
      }
      if ($Namespace) {
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
      }
      
      # Get StatefulSets
      $statefulsets = if ($KubeData?.StatefulSets) {
        $KubeData.StatefulSets
      } else {
        (kubectl get statefulsets -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $statefulsets = Exclude-Namespaces -items $statefulsets
      }
      if ($Namespace) {
        $statefulsets = $statefulsets | Where-Object { $_.metadata.namespace -eq $Namespace }
      }
      
      # Collect results
      $results = @()
      
      foreach ($hpa in $hpas) {
        $ns = $hpa.metadata.namespace
        $name = $hpa.metadata.name
        $targetKind = $hpa.spec.scaleTargetRef.kind
        $targetName = $hpa.spec.scaleTargetRef.name
        $targetRef = "$targetKind/$targetName"
        $status = $hpa.status
        $current = $status.currentReplicas
        $desired = $status.desiredReplicas
      
        $conditions = @{}
        if ($status.conditions) {
          foreach ($c in $status.conditions) {
            $conditions[$c.type] = $c
          }
        }
      
        $targetFound = switch ($targetKind) {
          "Deployment"  { ($deployments | Where-Object { $_.metadata.namespace -eq $ns -and $_.metadata.name -eq $targetName }).Count }
          "StatefulSet" { ($statefulsets | Where-Object { $_.metadata.namespace -eq $ns -and $_.metadata.name -eq $targetName }).Count }
          default       { 0 }
        }
      
        if ($targetFound -eq 0) {
          $results += [pscustomobject]@{
            Namespace = $ns
            HPA       = $name
            Target    = $targetRef
            Replicas  = ""
            Message   = "‚ùå Target not found"
          }
          continue
        }
      
        if (-not $status.currentMetrics -or $status.currentMetrics.Count -eq 0) {
          $results += [pscustomobject]@{
            Namespace = $ns
            HPA       = $name
            Target    = $targetRef
            Replicas  = ""
            Message   = "‚ùå No metrics available"
          }
        }
      
        if ($conditions["AbleToScale"]?.status -eq "False") {
          $msg = $conditions["AbleToScale"].reason
          $results += [pscustomobject]@{
            Namespace = $ns
            HPA       = $name
            Target    = $targetRef
            Replicas  = ""
            Message   = "‚ö†Ô∏è Scaling disabled: $msg"
          }
        }
      
        if ($conditions["ScalingActive"]?.status -eq "False") {
          $msg = $conditions["ScalingActive"].reason
          $results += [pscustomobject]@{
            Namespace = $ns
            HPA       = $name
            Target    = $targetRef
            Replicas  = ""
            Message   = "‚ö†Ô∏è Scaling not active: $msg"
          }
        }
      
        if ($desired -eq 0 -and $current -eq 0) {
          $results += [pscustomobject]@{
            Namespace = $ns
            HPA       = $name
            Target    = $targetRef
            Replicas  = ""
            Message   = "‚ö†Ô∏è HPA inactive (0 replicas)"
          }
        }
      
        if ($desired -ne $null -and $current -ne $null -and $desired -ne $current) {
          $results += [pscustomobject]@{
            Namespace = $ns
            HPA       = $name
            Target    = $targetRef
            Replicas  = "$current ‚Üí $desired"
            Message   = "‚ö†Ô∏è Scaling mismatch"
          }
        }
      }

      $results
  - ID: "WRK005"
    Name: "Missing Resource Requests or Limits"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "Pod"
    Severity: "warning"
    Weight: 3
    Description: "Checks that every container has CPU and memory requests and a memory limit."
    FailMessage: "One or more containers are missing a resource request or a memory limit."
    URL: "https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
    Recommendation:
      text: "Define cpu/memory requests and a memory limit on all containers."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Add <code>resources.requests.cpu</code> and <code>resources.requests.memory</code> to <strong>every</strong> container.</li>
            <li>Set a <code>resources.limits.memory</code> value to protect nodes from OOM events.</li>
            <li><em>CPU limits are optional</em>; include <code>resources.limits.cpu</code> only when you need strict throttling.</li>
            <li>Review both workload and <code>initContainers</code> with <code>kubectl get deploy,statefulset,daemonset -A -o yaml</code>.</li>
            <li>Apply any missing fields, then rerun KubeBuddy to confirm.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some containers are still missing resource requests or a memory limit."
      - ""
      - "‚ö†Ô∏è Without requests the scheduler can‚Äôt make good placement decisions."
      - "üí° Memory limits help prevent node OOMs; CPU limits are optional by design."
    Script: |
      param(
          [object]$KubeData,
          [string]$Namespace,
          [switch]$ExcludeNamespaces
      )
      
      # ------------------------------------------------------------------
      # Helper: evaluate a single container for missing resource settings
      # ------------------------------------------------------------------
      function Test-ContainerResources {
          param(
              [object]$Container,
              [string]$ContainerType,
              [string]$Namespace,
              [string]$Workload
          )
      
          $limits   = $Container.resources
          $requests = $Container.resources
      
          $missing = @()
      
          # Robust presence checks ---------------------------------------
          $cpuReq    = if ($requests) { $requests.requests?.cpu } else { $null }
          $memReq    = if ($requests) { $requests.requests?.memory } else { $null }
          $memLimit  = if ($limits)   { $limits.limits?.memory    } else { $null }
      
          if ([string]::IsNullOrWhiteSpace($cpuReq))   { $missing += 'CPU request' }
          if ([string]::IsNullOrWhiteSpace($memReq))   { $missing += 'Memory request' }
          if ([string]::IsNullOrWhiteSpace($memLimit)) { $missing += 'Memory limit' }
      
          if ($missing) {
              [pscustomobject]@{
                  Namespace     = $Namespace
                  Workload      = $Workload
                  Container     = $Container.name
                  ContainerType = $ContainerType
                  Message       = ($missing -join ', ') + ' missing'
              }
          }
      }
      
      # ------------------------------------------------------------------
      # Gather workloads (deployments, statefulsets, daemonsets)
      # ------------------------------------------------------------------
      $kinds = @('deployments','statefulsets','daemonsets')
      $workloads = foreach ($plural in $kinds) {
      
          # Create a singular Kind name with an initial capital letter
          $kind = ($plural -replace 's$') -creplace '^.', { $_.Value.ToUpper() }
      
          $items = if ($KubeData -and $KubeData[$plural]) {
              $KubeData[$plural]
          } else {
              (kubectl get $plural -A -o json | ConvertFrom-Json).items
          }
      
          if ($ExcludeNamespaces) { $items = Exclude-Namespaces -items $items }
          if ($Namespace)        { $items = $items | Where-Object { $_.metadata.namespace -eq $Namespace } }
      
          foreach ($w in $items) {
              if (-not $w.PSObject.Properties['kind']) {
                  $w | Add-Member kind $kind
              }
              $w
          }
      }
      
      # ------------------------------------------------------------------
      # Evaluate each container / initContainer in the workloads
      # ------------------------------------------------------------------
      $results = @()
      
      foreach ($w in $workloads) {
          $spec = $w.spec?.template?.spec
          if (-not $spec) { continue }
      
          # Regular containers
          foreach ($c in ($spec.containers | Where-Object { $_ })) {
              $results += Test-ContainerResources `
                  -Container $c `
                  -ContainerType 'Container' `
                  -Namespace $w.metadata.namespace `
                  -Workload "$("$($w.kind)/$($w.metadata.name)")"
          }
      
          # Init containers
          foreach ($c in ($spec.initContainers | Where-Object { $_ })) {
              $results += Test-ContainerResources `
                  -Container $c `
                  -ContainerType 'InitContainer' `
                  -Namespace $w.metadata.namespace `
                  -Workload "$("$($w.kind)/$($w.metadata.name)")"
          }
      }
      
      $results


  - ID: "WRK006"
    Name: "PDB Coverage and Effectiveness"
    Section: "Workloads"
    Category: "PDBs"
    ResourceKind: "PodDisruptionBudget"
    Severity: "critical"
    Weight: 2
    Description: "Detects missing or weak PDBs for workloads"
    FailMessage: "Workload is unprotected or PDB is weak"
    Recommendation:
      text: "Workloads should have a valid PDB to prevent availability issues during disruptions."
      html: |
        <ul>
          <li>Set <code>minAvailable</code> to a safe minimum (not 0).</li>
          <li>Avoid setting <code>maxUnavailable</code> to <code>1</code> or <code>100%</code>.</li>
          <li>Make sure PDBs match actual workloads via label selectors.</li>
        </ul>
    SpeechBubble:
      - "ü§ñ Some workloads have missing or weak PodDisruptionBudgets."
      - ""
      - "üìå PDBs help ensure availability during voluntary disruptions."
      - ""
      - "‚ö†Ô∏è Add or adjust PDBs to protect critical workloads."
    URL: "https://kubernetes.io/docs/tasks/run-application/configure-pdb/"
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      function IsWeakPDB($pdb) {
        if ($pdb.spec.minAvailable -eq 0) { return "‚ö†Ô∏è minAvailable = 0" }
        if ($pdb.spec.maxUnavailable -eq 1 -or $pdb.spec.maxUnavailable -eq "100%" -or $pdb.spec.maxUnavailable -eq "1") {
          return "‚ö†Ô∏è maxUnavailable = 100%"
        }
        return $null
      }

      function MatchesSelector($labels, $selector) {
        foreach ($key in $selector.matchLabels.Keys) {
          if (-not $labels.ContainsKey($key) -or $labels[$key] -ne $selector.matchLabels[$key]) {
            return $false
          }
        }
        return $true
      }

      $results = @()
      $pdbs = if ($KubeData?.PodDisruptionBudgets) {
        $KubeData.PodDisruptionBudgets
      } else {
        (kubectl get pdb -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $pdbs = Exclude-Namespaces -items $pdbs
      }
      if ($Namespace) {
        $pdbs = $pdbs | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $pods = if ($KubeData?.Pods) {
        $KubeData.Pods.items
      } else {
        (kubectl get pods -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $pods = Exclude-Namespaces -items $pods
      }
      if ($Namespace) {
        $pods = $pods | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $deployments = if ($KubeData?.Deployments) {
        $KubeData.Deployments
      } else {
        (kubectl get deployments -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $deployments = Exclude-Namespaces -items $deployments
      }
      if ($Namespace) {
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $statefulsets = if ($KubeData?.StatefulSets) {
        $KubeData.StatefulSets
      } else {
        (kubectl get statefulsets -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $statefulsets = Exclude-Namespaces -items $statefulsets
      }
      if ($Namespace) {
        $statefulsets = $statefulsets | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      foreach ($pdb in $pdbs) {
        $weak = IsWeakPDB $pdb
        if ($weak) {
          $results += [PSCustomObject]@{
            Namespace = $pdb.metadata.namespace
            Name      = $pdb.metadata.name
            Kind      = "PDB"
            Issue     = $weak
          }
        }
        if ($pdb.status.expectedPods -eq 0) {
          $results += [PSCustomObject]@{
            Namespace = $pdb.metadata.namespace
            Name      = $pdb.metadata.name
            Kind      = "PDB"
            Issue     = "‚ö†Ô∏è Matches 0 pods"
          }
        }
      }

      $allWorkloads = @()
      $allWorkloads += $deployments | Where-Object { $_ -ne $null } | ForEach-Object {
        $_ | Add-Member -NotePropertyName kind -NotePropertyValue "Deployment" -Force -PassThru
      }
      $allWorkloads += $statefulsets | Where-Object { $_ -ne $null } | ForEach-Object {
        $_ | Add-Member -NotePropertyName kind -NotePropertyValue "StatefulSet" -Force -PassThru
      }

      foreach ($workload in $allWorkloads) {
        $ns = $workload.metadata.namespace
        $name = $workload.metadata.name
        $kind = $workload.kind
        $labels = $workload.spec.template.metadata.labels

        $matched = $false
        foreach ($pdb in $pdbs | Where-Object { $_.metadata.namespace -eq $ns }) {
          if ($pdb.spec.selector -and $pdb.spec.selector.matchLabels) {
            if (MatchesSelector $labels $pdb.spec.selector) {
              $matched = $true
              break
            }
          }
        }

        if (-not $matched) {
          $results += [PSCustomObject]@{
            Namespace = $ns
            Name      = $name
            Kind      = $kind
            Issue     = "‚ùå No matching PDB"
          }
        }
      }

      return $results
  - ID: "WRK007"
    Name: "Missing Readiness and Liveness Probes"
    Section: "Workloads"
    Category: "Probes"
    ResourceKind: "Deployment"
    Severity: "warning"
    Weight: 4
    Description: "Detects containers without health probes (readiness/liveness)."
    FailMessage: "Missing readiness or liveness probes."
    Recommendation:
      text: "Add readiness and liveness probes to all containers to improve availability and fault detection."
      html: |
        <ul>
          <li><strong>Readiness probes</strong> indicate when a container is ready to receive traffic.</li>
          <li><strong>Liveness probes</strong> detect if a container is stuck or dead.</li>
          <li>Use <code>httpGet</code>, <code>tcpSocket</code>, or <code>exec</code> probes for most apps.</li>
          <li>Docs: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Health probes in Kubernetes</a></li>
        </ul>
    SpeechBubble:
      - "ü§ñ Some containers are missing readiness or liveness probes."
      - ""
      - "üìå These help Kubernetes detect unresponsive apps early."
      - ""
      - "‚ö†Ô∏è Add probes to improve fault tolerance and traffic routing."
    URL: "https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/"
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)
      
      $results = @()
      $workloadTypes = @("deployments", "statefulsets", "daemonsets")
      
      $items = @()
      foreach ($type in $workloadTypes) {
          # ‚Äî‚Äî‚Äî BEGIN PATCH ‚Äî‚Äî‚Äî
          # Grab the list of property names on the PSCustomObject
          $propNames = if ($KubeData) { $KubeData.PSObject.Properties.Name } else { @() }
      
          if ($propNames -contains $type) {
              # Use the in-memory data
              $blob = $KubeData.$type
              $raw = if ($blob.PSObject.Properties.Name -contains 'items') { $blob.items } else { $blob }
          }
          else {
              # Fall back to kubectl
              $raw = (kubectl get $type --all-namespaces -o json | ConvertFrom-Json).items
          }
          # ‚Äî‚Äî‚Äî END PATCH ‚Äî‚Äî‚Äî
      
          if ($ExcludeNamespaces) {
              $raw = Exclude-Namespaces -items $raw
          }
          if ($Namespace) {
              $raw = $raw | Where-Object { $_.metadata.namespace -eq $Namespace }
          }
      
          $kind = ($type -replace "s$")
          $kind = $kind.Substring(0, 1).ToUpper() + $kind.Substring(1)
          $items += $raw | ForEach-Object {
              if (-not $_.PSObject.Properties['kind']) {
                  $_ | Add-Member -NotePropertyName kind -NotePropertyValue $kind -PassThru
              } else {
                  $_
              }
          }
      }
      
      foreach ($w in $items) {
          $ns = $w.metadata.namespace
          $name = $w.metadata.name
          $kind = $w.kind
          if (-not $w.spec -or -not $w.spec.template -or -not $w.spec.template.spec -or -not $w.spec.template.spec.containers) {
              continue
          }
          $containers = $w.spec.template.spec.containers
      
          foreach ($c in $containers) {
              $missing = @()
              if (-not $c.readinessProbe) { $missing += "readiness" }
              if (-not $c.livenessProbe)  { $missing += "liveness"  }
      
              if ($missing.Count -gt 0) {
                  $results += [PSCustomObject]@{
                      Namespace = $ns
                      Workload  = $name
                      Kind      = $kind
                      Container = $c.name
                      Missing   = $missing -join ", "
                  }
              }
          }
      }
      
      return $results

  - ID: "WRK008"
    Name: "Deployment Selector Without Matching Pods"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "Deployment"
    Severity: "warning"
    Weight: 2
    Description: "Detects Deployments whose spec.selector does not match any existing Pods. This results in 0 replicas running."
    FailMessage: "Deployment selector does not match any Pods"
    Recommendation:
      text: "Ensure that pod labels match the Deployment selector."
      html: |
        <ul>
          <li>Check that Deployment's <code>spec.selector.matchLabels</code> matches the pod template's labels.</li>
          <li>Fix any label mismatches to allow pods to be created.</li>
        </ul>
    URL: "https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      $deployments = $KubeData?.deployments ?? (kubectl get deployments -A -o json | ConvertFrom-Json).items
      $pods = $KubeData?.Pods?.items ?? (kubectl get pods -A -o json | ConvertFrom-Json).items
  
      if ($ExcludeNamespaces) {
        $deployments = Exclude-Namespaces -items $deployments
        $pods = Exclude-Namespaces -items $pods
      }
      if ($Namespace) {
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
        $pods = $pods | Where-Object { $_.metadata.namespace -eq $Namespace }
      }
  
      function Matches-Selector {
        param($pod, $selector)
        foreach ($key in $selector.Keys) {
          if (-not $pod.metadata.labels.ContainsKey($key)) { return $false }
          if ($pod.metadata.labels[$key] -ne $selector[$key]) { return $false }
        }
        return $true
      }
  
      $results = @()
      foreach ($dep in $deployments) {
        $selector = $dep.spec?.selector?.matchLabels
        if (-not $selector) { continue }
        $ns = $dep.metadata.namespace
  
        $matchingPods = $pods | Where-Object {
          $_.metadata.namespace -eq $ns -and (Matches-Selector $_ $selector)
        }
  
        if (-not $matchingPods -or $matchingPods.Count -eq 0) {
          $results += [pscustomobject]@{
            "Namespace"       = $ns
            "Deployment"        = "$($dep.metadata.name)"
            "Matched Pod"           = "0 matching pods"
            "Issue Summary"         = "Deployment selector does not match any pods"
          }
        }
      }
  
      return $results
  - ID: "WRK009"
    Name: "Deployment, Pod, and Service Label Consistency"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "Deployment"
    Severity: "warning"
    Weight: 3
    Description: "Validates that Pods created by a Deployment match its selector labels, and Services that target the Deployment use consistent selectors."
    FailMessage: "Label mismatches found between Deployment selectors, Pod labels, or Service selectors."
    URL: "https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/"
    Recommendation:
      text: "Ensure Deployment selectors, Pod labels, and related Service selectors are consistent and aligned."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Deployment <code>spec.selector.matchLabels</code> must match the Pod template <code>metadata.labels</code>.</li>
            <li>Services should have <code>spec.selector</code> that targets the same labels used by the Deployment and Pods.</li>
            <li>Use <code>kubectl get deployment,svc,pod -o yaml</code> to compare values and fix mismatches.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some labels are inconsistent across Deployments, Pods, and Services."
      - ""
      - "üìå This may break Service routing or monitoring integrations."
      - ""
      - "‚ö†Ô∏è Align label selectors to ensure traffic and tooling works as expected."
    Script: |
      param ([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)
      
      $deployments = if ($KubeData?.Deployments) {
          $KubeData.Deployments
      } else {
          (kubectl get deployments -A -o json | ConvertFrom-Json).items
      }
      
      $pods = if ($KubeData?.Pods) {
          $KubeData.Pods.items
      } else {
          (kubectl get pods -A -o json | ConvertFrom-Json).items
      }
      
      $services = if ($KubeData?.Services) {
          $KubeData.Services
      } else {
          (kubectl get services -A -o json | ConvertFrom-Json).items
      }
      
      if ($ExcludeNamespaces) {
          $deployments = Exclude-Namespaces -items $deployments
          $pods = Exclude-Namespaces -items $pods
          $services = Exclude-Namespaces -items $services
      }
      
      if ($Namespace) {
          $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
          $pods = $pods | Where-Object { $_.metadata.namespace -eq $Namespace }
          $services = $services | Where-Object { $_.metadata.namespace -eq $Namespace }
      }
      
      $results = @()
      
      foreach ($deployment in $deployments) {
          $ns = $deployment.metadata.namespace
          $dname = $deployment.metadata.name
          $selector = $deployment.spec.selector.matchLabels
          $templateLabels = $deployment.spec.template.metadata.labels
      
          if (-not $selector) {
              $results += [PSCustomObject]@{
                  Namespace  = $ns
                  Type       = "Deployment Error"
                  Deployment = $dname
                  LabelKey   = $null
                  Expected   = $null
                  Actual     = $null
                  Message    = "Deployment has no selector.matchLabels defined"
              }
              continue
          }
      
          # 1. Check Pod label mismatch
          foreach ($key in $selector.PSObject.Properties.Name) {
              $expected = $selector.$key
              $actual = $templateLabels.$key
              if ($actual -ne $expected) {
                  $results += [PSCustomObject]@{
                      Namespace  = $ns
                      Type       = "Deployment->Pod Mismatch"
                      Deployment = $dname
                      LabelKey   = $key
                      Expected   = $expected
                      Actual     = $actual ?? "<missing>"
                      Message    = "Deployment selector key '$key' does not match Pod template label"
                  }
              }
          }
      
          # 2. Check Service selector mismatch (only for relevant Services)
          $relatedSvcs = $services | Where-Object {
              $_.metadata.namespace -eq $ns -and $_.spec.selector -and
              # Check if Service selector has at least one matching key-value pair with Deployment selector
              ($_.spec.selector.PSObject.Properties.Name | Where-Object {
                  $selector.$_ -and $selector.$_ -eq $_.spec.selector.$_
              }).Count -gt 0
          }
      
          foreach ($svc in $relatedSvcs) {
              $svcName = $svc.metadata.name
              foreach ($key in $selector.PSObject.Properties.Name) {
                  $svcValue = $svc.spec.selector.$key
                  $depValue = $selector.$key
                  if ($svcValue -and $svcValue -ne $depValue) {
                      $results += [PSCustomObject]@{
                          Namespace  = $ns
                          Type       = "Deployment->Service Mismatch"
                          Deployment = $dname
                          Service    = $svcName
                          LabelKey   = $key
                          Expected   = $depValue
                          Actual     = $svcValue
                          Message    = "Service '$svcName' selector key '$key' does not match Deployment selector"
                      }
                  }
                  elseif (-not $svcValue -and $depValue) {
                      $results += [PSCustomObject]@{
                          Namespace  = $ns
                          Type       = "Deployment->Service Mismatch"
                          Deployment = $dname
                          Service    = $svcName
                          LabelKey   = $key
                          Expected   = $depValue
                          Actual     = "<missing>"
                          Message    = "Service '$svcName' selector is missing key '$key' present in Deployment selector"
                      }
                  }
              }
          }
      }
      
      return $results

  - ID: "WRK010"
    Name: "HPA Metrics Without Matching Resource Requests"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "HorizontalPodAutoscaler"
    Severity: "warning"
    Weight: 3
    Description: "Detects HPAs that scale on CPU/memory metrics while target containers are missing corresponding resource requests."
    FailMessage: "HPA targets are missing CPU/memory requests required for reliable autoscaling."
    URL: "https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"
    Recommendation:
      text: "Set resource requests for HPA-managed workloads so autoscaling decisions are based on valid utilization signals."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Add <code>resources.requests.cpu</code> and/or <code>resources.requests.memory</code> for HPA target containers.</li>
            <li>Use consistent requests across replicas to avoid unstable scaling behavior.</li>
            <li>After updates, validate HPA behavior with <code>kubectl describe hpa</code>.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some HPAs rely on CPU/memory metrics but target containers miss matching requests."
      - ""
      - "‚ö†Ô∏è This can make autoscaling noisy or inaccurate."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      $hpas = if ($KubeData?.HorizontalPodAutoscalers) { @($KubeData.HorizontalPodAutoscalers) } else { @((kubectl get hpa -A -o json | ConvertFrom-Json).items) }
      $deployments = if ($KubeData?.Deployments) { @($KubeData.Deployments) } else { @((kubectl get deployments -A -o json | ConvertFrom-Json).items) }
      $statefulsets = if ($KubeData?.StatefulSets) { @($KubeData.StatefulSets) } else { @((kubectl get statefulsets -A -o json | ConvertFrom-Json).items) }

      if ($ExcludeNamespaces) {
        $hpas = Exclude-Namespaces -items $hpas
        $deployments = Exclude-Namespaces -items $deployments
        $statefulsets = Exclude-Namespaces -items $statefulsets
      }
      if ($Namespace) {
        $hpas = $hpas | Where-Object { $_.metadata.namespace -eq $Namespace }
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
        $statefulsets = $statefulsets | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $results = @()

      foreach ($hpa in $hpas) {
        $ns = $hpa.metadata.namespace
        $hpaName = $hpa.metadata.name
        $targetKind = "$($hpa.spec.scaleTargetRef.kind)"
        $targetName = "$($hpa.spec.scaleTargetRef.name)"

        $resourceMetrics = @($hpa.spec.metrics | Where-Object { $_.type -eq "Resource" -and $_.resource.name -in @("cpu","memory") })
        if (-not $resourceMetrics -or $resourceMetrics.Count -eq 0) { continue }

        $workload = $null
        if ($targetKind -eq "Deployment") {
          $workload = $deployments | Where-Object { $_.metadata.namespace -eq $ns -and $_.metadata.name -eq $targetName } | Select-Object -First 1
        } elseif ($targetKind -eq "StatefulSet") {
          $workload = $statefulsets | Where-Object { $_.metadata.namespace -eq $ns -and $_.metadata.name -eq $targetName } | Select-Object -First 1
        }
        if (-not $workload) { continue }

        $containers = @($workload.spec.template.spec.containers)
        foreach ($m in $resourceMetrics) {
          $metricName = "$($m.resource.name)"
          $missing = @()
          foreach ($c in $containers) {
            $reqVal = if ($metricName -eq "cpu") { $c.resources.requests.cpu } else { $c.resources.requests.memory }
            if (-not $reqVal) {
              $missing += $c.name
            }
          }

          if ($missing.Count -gt 0) {
            $results += [PSCustomObject]@{
              Namespace = $ns
              HPA = $hpaName
              Target = "$targetKind/$targetName"
              Metric = $metricName
              MissingContainers = ($missing -join ", ")
              Message = "Containers missing $metricName requests"
            }
          }
        }
      }

      return $results

  - ID: "WRK011"
    Name: "VPA Update Mode and Declarative Resource Conflict Risk"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "VerticalPodAutoscaler"
    Severity: "warning"
    Weight: 2
    Description: "Flags VPAs in Auto/Recreate mode where targets are declaratively managed with fixed requests or overlap with HPA resource scaling."
    FailMessage: "VPA mode may conflict with declarative resource settings or HPA scaling."
    URL: "https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler"
    Recommendation:
      text: "Use VPA Off/Initial for recommendation-only flows, or tune ownership boundaries when combining VPA with HPA/GitOps."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>If GitOps/Helm controls requests, consider VPA <code>updateMode: Off</code> or <code>Initial</code>.</li>
            <li>Avoid overlapping HPA (CPU/memory) and VPA ownership without clear boundaries.</li>
            <li>Document which controller owns requests per workload.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Some VPA configurations may fight with declarative config or HPA."
      - ""
      - "‚ö†Ô∏è Clarify autoscaling ownership boundaries."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      $vpas = if ($KubeData?.CustomResourcesByKind -and $KubeData.CustomResourcesByKind.ContainsKey("VerticalPodAutoscaler")) {
        @($KubeData.CustomResourcesByKind["VerticalPodAutoscaler"])
      } else {
        @((kubectl get verticalpodautoscalers.autoscaling.k8s.io --all-namespaces -o json --ignore-not-found 2>$null | ConvertFrom-Json -ErrorAction SilentlyContinue).items)
      }
      $hpas = if ($KubeData?.HorizontalPodAutoscalers) { @($KubeData.HorizontalPodAutoscalers) } else { @((kubectl get hpa -A -o json | ConvertFrom-Json).items) }
      $deployments = if ($KubeData?.Deployments) { @($KubeData.Deployments) } else { @((kubectl get deployments -A -o json | ConvertFrom-Json).items) }
      $statefulsets = if ($KubeData?.StatefulSets) { @($KubeData.StatefulSets) } else { @((kubectl get statefulsets -A -o json | ConvertFrom-Json).items) }

      if ($ExcludeNamespaces) {
        $vpas = Exclude-Namespaces -items $vpas
        $hpas = Exclude-Namespaces -items $hpas
        $deployments = Exclude-Namespaces -items $deployments
        $statefulsets = Exclude-Namespaces -items $statefulsets
      }
      if ($Namespace) {
        $vpas = $vpas | Where-Object { $_.metadata.namespace -eq $Namespace }
        $hpas = $hpas | Where-Object { $_.metadata.namespace -eq $Namespace }
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
        $statefulsets = $statefulsets | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $results = @()

      foreach ($vpa in $vpas) {
        $ns = $vpa.metadata.namespace
        $vpaName = $vpa.metadata.name
        $targetKind = "$($vpa.spec.targetRef.kind)"
        $targetName = "$($vpa.spec.targetRef.name)"
        if (-not $targetKind -or -not $targetName) { continue }

        $updateMode = if ($vpa.spec.updatePolicy.updateMode) { "$($vpa.spec.updatePolicy.updateMode)" } else { "Auto" }
        if ($updateMode -notin @("Auto", "Recreate")) { continue }

        $workload = $null
        if ($targetKind -eq "Deployment") {
          $workload = $deployments | Where-Object { $_.metadata.namespace -eq $ns -and $_.metadata.name -eq $targetName } | Select-Object -First 1
        } elseif ($targetKind -eq "StatefulSet") {
          $workload = $statefulsets | Where-Object { $_.metadata.namespace -eq $ns -and $_.metadata.name -eq $targetName } | Select-Object -First 1
        }
        if (-not $workload) { continue }

        $containers = @($workload.spec.template.spec.containers)
        $withRequests = @($containers | Where-Object { $_.resources.requests.cpu -or $_.resources.requests.memory })
        if ($withRequests.Count -eq 0) { continue }

        $managedBy = if ($workload.metadata.labels.'app.kubernetes.io/managed-by') {
          "$($workload.metadata.labels.'app.kubernetes.io/managed-by')"
        } else {
          "unknown"
        }
        $isDeclarative = $managedBy.ToLower() -in @("helm", "argocd", "flux", "kustomize", "terraform")

        $hasHpaConflict = $false
        foreach ($hpa in $hpas | Where-Object {
          $_.metadata.namespace -eq $ns -and
          "$($_.spec.scaleTargetRef.kind)" -eq $targetKind -and
          "$($_.spec.scaleTargetRef.name)" -eq $targetName
        }) {
          if (@($hpa.spec.metrics | Where-Object { $_.type -eq "Resource" -and $_.resource.name -in @("cpu","memory") }).Count -gt 0) {
            $hasHpaConflict = $true
            break
          }
        }

        if ($isDeclarative -or $hasHpaConflict) {
          $reasons = @()
          if ($isDeclarative) { $reasons += "Declarative manager detected ($managedBy)" }
          if ($hasHpaConflict) { $reasons += "HPA also scales this target via CPU/memory metrics" }
          $results += [PSCustomObject]@{
            Namespace = $ns
            VPA = $vpaName
            Target = "$targetKind/$targetName"
            UpdateMode = $updateMode
            ManagedBy = $managedBy
            Message = ($reasons -join "; ")
          }
        }
      }

      return $results

  - ID: "WRK012"
    Name: "PodDisruptionBudget Adequacy for Replicated Workloads"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "PodDisruptionBudget"
    Severity: "warning"
    Weight: 2
    Description: "Evaluates PDB coverage and disruption settings for Deployments/StatefulSets with 2+ replicas."
    FailMessage: "Replicated workloads are missing PDBs or have risky disruption settings."
    URL: "https://kubernetes.io/docs/tasks/run-application/configure-pdb/"
    Recommendation:
      text: "Add or tune PDBs so maintenance can proceed safely without over-restricting disruption."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Ensure replicated workloads (2+ replicas) have a matching PDB.</li>
            <li>Avoid <code>minAvailable</code> equal to replica count for normal maintenance windows.</li>
            <li>Use pragmatic budgets (for example <code>maxUnavailable: 1</code> for many workloads).</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Checking if PDB coverage and settings are practical."
      - ""
      - "‚ö†Ô∏è Missing or overly strict PDBs can block maintenance and upgrades."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      $pdbs = if ($KubeData?.PodDisruptionBudgets) { @($KubeData.PodDisruptionBudgets) } else { @((kubectl get pdb -A -o json | ConvertFrom-Json).items) }
      $deployments = if ($KubeData?.Deployments) { @($KubeData.Deployments) } else { @((kubectl get deployments -A -o json | ConvertFrom-Json).items) }
      $statefulsets = if ($KubeData?.StatefulSets) { @($KubeData.StatefulSets) } else { @((kubectl get statefulsets -A -o json | ConvertFrom-Json).items) }

      if ($ExcludeNamespaces) {
        $pdbs = Exclude-Namespaces -items $pdbs
        $deployments = Exclude-Namespaces -items $deployments
        $statefulsets = Exclude-Namespaces -items $statefulsets
      }
      if ($Namespace) {
        $pdbs = $pdbs | Where-Object { $_.metadata.namespace -eq $Namespace }
        $deployments = $deployments | Where-Object { $_.metadata.namespace -eq $Namespace }
        $statefulsets = $statefulsets | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      function Selector-Matches {
        param($labels, $selector)
        if (-not $selector) { return $false }
        if (-not $labels) { return $false }
        foreach ($k in $selector.PSObject.Properties.Name) {
          $hasKey = $false
          $actual = $null
          if ($labels -is [System.Collections.IDictionary]) {
            $hasKey = $labels.Contains($k)
            if ($hasKey) { $actual = $labels[$k] }
          } else {
            $prop = $labels.PSObject.Properties[$k]
            if ($prop) {
              $hasKey = $true
              $actual = $prop.Value
            }
          }
          if (-not $hasKey -or "$actual" -ne "$($selector.$k)") { return $false }
        }
        return $true
      }

      function Resolve-IntOrPercent {
        param($raw, [int]$replicas)
        if ($null -eq $raw) { return $null }
        $txt = "$raw"
        if ($txt -match '^\d+%$') {
          $pct = [int]$txt.TrimEnd('%')
          return [int][Math]::Ceiling(($replicas * $pct) / 100.0)
        }
        if ($txt -match '^\d+$') { return [int]$txt }
        return $null
      }

      $workloads = @()
      foreach ($d in $deployments) {
        $replicas = if ($d.spec.replicas -ne $null) { [int]$d.spec.replicas } else { 1 }
        if ($replicas -ge 2) {
          $workloads += [PSCustomObject]@{
            Namespace = $d.metadata.namespace
            Kind = "Deployment"
            Name = $d.metadata.name
            Replicas = $replicas
            Labels = $d.spec.template.metadata.labels
          }
        }
      }
      foreach ($s in $statefulsets) {
        $replicas = if ($s.spec.replicas -ne $null) { [int]$s.spec.replicas } else { 1 }
        if ($replicas -ge 2) {
          $workloads += [PSCustomObject]@{
            Namespace = $s.metadata.namespace
            Kind = "StatefulSet"
            Name = $s.metadata.name
            Replicas = $replicas
            Labels = $s.spec.template.metadata.labels
          }
        }
      }

      $results = @()
      foreach ($w in $workloads) {
        $matching = @($pdbs | Where-Object {
          $_.metadata.namespace -eq $w.Namespace -and
          $_.spec.selector -and $_.spec.selector.matchLabels -and
          (Selector-Matches -labels $w.Labels -selector $_.spec.selector.matchLabels)
        })

        if ($matching.Count -eq 0) {
          $results += [PSCustomObject]@{
            Namespace = $w.Namespace
            Workload = "$($w.Kind)/$($w.Name)"
            Replicas = $w.Replicas
            PDB = "<none>"
            Setting = "-"
            Message = "No matching PDB for replicated workload"
          }
          continue
        }

        foreach ($p in $matching) {
          $minRaw = $p.spec.minAvailable
          $maxRaw = $p.spec.maxUnavailable
          $minVal = Resolve-IntOrPercent -raw $minRaw -replicas $w.Replicas
          $maxVal = Resolve-IntOrPercent -raw $maxRaw -replicas $w.Replicas

          $issues = @()
          if ($minVal -ne $null -and $minVal -ge $w.Replicas) { $issues += "minAvailable may be too strict for disruptions" }
          if ($maxVal -ne $null -and $maxVal -le 0) { $issues += "maxUnavailable blocks voluntary disruption" }
          if ($maxVal -ne $null -and $maxVal -ge $w.Replicas) { $issues += "maxUnavailable may be too permissive" }

          if ($issues.Count -gt 0) {
            $setting = if ($minRaw -ne $null) { "minAvailable=$minRaw" } elseif ($maxRaw -ne $null) { "maxUnavailable=$maxRaw" } else { "unset" }
            $results += [PSCustomObject]@{
              Namespace = $w.Namespace
              Workload = "$($w.Kind)/$($w.Name)"
              Replicas = $w.Replicas
              PDB = $p.metadata.name
              Setting = $setting
              Message = ($issues -join "; ")
            }
          }
        }
      }

      return $results

  - ID: "WRK013"
    Name: "CrashLoopBackOff and OOMKilled Guardrail"
    Category: "Workloads"
    Section: "Workloads"
    ResourceKind: "Pod"
    Severity: "critical"
    Weight: 3
    Description: "Highlights pods with CrashLoopBackOff or OOMKilled signals to guard against unsafe downsizing decisions."
    FailMessage: "CrashLoopBackOff/OOMKilled pods detected."
    URL: "https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
    Recommendation:
      text: "Stabilize CrashLoop/OOM pods before applying aggressive right-sizing changes."
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Investigate container logs and termination reasons for recurring restarts.</li>
            <li>Increase memory requests/limits when OOMKilled events are observed.</li>
            <li>Apply sizing changes gradually and validate SLO/error rates.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Found CrashLoopBackOff or OOMKilled signals."
      - ""
      - "‚ö†Ô∏è Treat right-sizing for these pods with extra caution."
    Script: |
      param([object]$KubeData, $Namespace, [switch]$ExcludeNamespaces)

      $pods = if ($KubeData?.Pods) {
        if ($KubeData.Pods.items) { @($KubeData.Pods.items) } else { @($KubeData.Pods) }
      } else {
        @((kubectl get pods -A -o json | ConvertFrom-Json).items)
      }
      if ($ExcludeNamespaces) {
        $pods = Exclude-Namespaces -items $pods
      }
      if ($Namespace) {
        $pods = $pods | Where-Object { $_.metadata.namespace -eq $Namespace }
      }

      $results = @()
      foreach ($pod in $pods) {
        $ns = $pod.metadata.namespace
        $podName = $pod.metadata.name
        $specContainers = @($pod.spec.containers)

        foreach ($cs in @($pod.status.containerStatuses)) {
          $name = $cs.name
          $restartCount = if ($cs.restartCount -ne $null) { [int]$cs.restartCount } else { 0 }
          $reasons = @()

          if ($cs.state.waiting.reason -eq "CrashLoopBackOff") { $reasons += "CrashLoopBackOff" }
          if ($cs.lastState.terminated.reason -eq "OOMKilled" -or $cs.state.terminated.reason -eq "OOMKilled") { $reasons += "OOMKilled" }
          if ($restartCount -ge 5) { $reasons += "HighRestarts($restartCount)" }

          if ($reasons.Count -eq 0) { continue }

          $spec = $specContainers | Where-Object { $_.name -eq $name } | Select-Object -First 1
          $results += [PSCustomObject]@{
            Namespace = $ns
            Pod = $podName
            Container = $name
            Restarts = $restartCount
            CPURequest = $spec.resources.requests.cpu
            CPULimit = $spec.resources.limits.cpu
            MemoryRequest = $spec.resources.requests.memory
            MemoryLimit = $spec.resources.limits.memory
            Message = ($reasons -join ", ")
          }
        }
      }

      return $results

checks:
  - ID: NS001
    Name: Empty Namespaces
    Section: Namespaces
    Category: Namespaces
    ResourceKind: namespaces
    Severity: low
    Weight: 1
    Description: Finds namespaces with no running pods.
    Recommendation:
      text: These may be stale or unused and safe to delete after verifying they contain no critical resources.
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Check if any other resources (PVCs, Secrets) exist before deleting.</li>
            <li>Use <code>kubectl get all -n <namespace></code> to inspect.</li>
            <li>Clean up empty namespaces to reduce clutter.</li>
          </ul>
        </div>
      SpeechBubble:
        - "ü§ñ Checking for empty namespaces."
        - ""
        - "üìå This check finds namespaces that have no running pods."
        - ""
        - "‚ö†Ô∏è These might be stale or unused but check for other resources like Secrets or PVCs before deleting."
    Script: |
      param($KubeData, $Namespace, [switch]$ExcludeNamespaces)
      $allNamespaces = if ($KubeData?.Namespaces) {
        $KubeData.Namespaces
      } else {
        (kubectl get namespaces -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $allNamespaces = Exclude-Namespaces -items $allNamespaces
      }

      $allNsNames = $allNamespaces | ForEach-Object { $_.metadata.name.Trim() }

      $pods = if ($KubeData?.Pods) {
        $KubeData.Pods.items | Where-Object { $_.metadata.namespace }
      } else {
        (kubectl get pods -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $pods = Exclude-Namespaces -items $pods
      }

      $pods = $pods | Group-Object { $_.metadata.namespace }

      $used = $pods | ForEach-Object { $_.Name.Trim() }
      $empty = $allNsNames | Where-Object { $_ -notin $used }

      $empty | ForEach-Object {
        [pscustomobject]@{
          Namespace = $_
          Status    = "üìÇ Empty"
        }
      }
    URL: "https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"
  - ID: NS002
    Name: Missing or Weak ResourceQuotas
    Section: Namespaces
    Category: Namespaces
    ResourceKind: resourcequotas
    Severity: medium
    Weight: 3
    Description: Detects namespaces with missing or incomplete ResourceQuota definitions.
    Recommendation:
      text: Apply CPU, memory, and pod quotas to enforce fair resource usage.
      html: |
        <div class="recommendation-content">
          <ul>
            <li>Define limits using <code>ResourceQuota</code> for pods, memory, and CPU.</li>
            <li>Helps avoid over-provisioning and noisy neighbor issues.</li>
            <li>Review quotas using <code>kubectl describe quota -n <namespace></code>.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Checking for missing or incomplete ResourceQuotas."
      - ""
      - "üìå This check flags namespaces that lack ResourceQuota settings or are missing limits for:"
      - "   - CPU"
      - "   - Memory"
      - "   - Pods"
      - ""
      - "‚ö†Ô∏è Incomplete quotas can lead to resource abuse and noisy neighbors."
    Script: |
      param($KubeData, $Namespace, [switch]$ExcludeNamespaces)
      $quotas = if ($KubeData?.ResourceQuotas) {
        $KubeData.ResourceQuotas
      } else {
        (kubectl get resourcequotas -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $quotas = Exclude-Namespaces -items $quotas
      }

      $namespaces = if ($KubeData?.Namespaces) {
        $KubeData.Namespaces
      } else {
        (kubectl get namespaces -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $namespaces = Exclude-Namespaces -items $namespaces
      }

      $results = @()
      foreach ($ns in $namespaces) {
        $nsName = $ns.metadata.name
        $q = $quotas | Where-Object { $_.metadata.namespace -eq $nsName }

        if (-not $q) {
          $results += [pscustomobject]@{ Namespace = $nsName; Issue = "‚ùå No ResourceQuota" }
        } else {
          $hasCPU = $false; $hasMemory = $false; $hasPods = $false
          foreach ($item in $q) {
            $p = $item.status.hard.PSObject.Properties.Name
            if ($p -contains "requests.cpu" -or $p -contains "limits.cpu") { $hasCPU = $true }
            if ($p -contains "requests.memory" -or $p -contains "limits.memory") { $hasMemory = $true }
            if ($p -contains "pods") { $hasPods = $true }
          }
          if (-not ($hasCPU -and $hasMemory -and $hasPods)) {
            $missing = @()
            if (-not $hasCPU) { $missing += "CPU" }
            if (-not $hasMemory) { $missing += "Memory" }
            if (-not $hasPods) { $missing += "Pods" }
            $results += [pscustomobject]@{
              Namespace = $nsName
              Issue     = "‚ö†Ô∏è Missing: $($missing -join ', ')"
            }
          }
        }
      }

      $results
    URL: "https://kubernetes.io/docs/concepts/policy/resource-quotas/"
  - ID: NS003
    Name: Missing LimitRanges
    Section: Namespaces
    Category: Namespaces
    ResourceKind: limitranges
    Severity: medium
    Weight: 2
    Description: Detects namespaces without a defined LimitRange.
    Recommendation:
      text: Define default CPU and memory limits to avoid unbounded pod usage.
      html: |
        <div class="recommendation-content">
          <ul>
            <li>LimitRanges define default and max values for CPU/memory.</li>
            <li>Prevents pods from using unlimited resources.</li>
            <li>Use <code>kubectl create limitrange ...</code> or <code>kubectl describe limitrange -n <namespace></code>.</li>
          </ul>
        </div>
    SpeechBubble:
      - "ü§ñ Checking for namespaces missing LimitRanges."
      - ""
      - "üìå LimitRanges define default and maximum CPU/memory for pods and containers."
      - ""
      - "‚ö†Ô∏è Without them, workloads may consume unbounded resources."
    Script: |
      param($KubeData, $Namespace, [switch]$ExcludeNamespaces)
      $limitRanges = if ($KubeData?.LimitRanges) {
        $KubeData.LimitRanges
      } else {
        (kubectl get limitranges -A -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $limitRanges = Exclude-Namespaces -items $limitRanges
      }

      $namespaces = if ($KubeData?.Namespaces) {
        $KubeData.Namespaces
      } else {
        (kubectl get namespaces -o json | ConvertFrom-Json).items
      }
      if ($ExcludeNamespaces) {
        $namespaces = Exclude-Namespaces -items $namespaces
      }

      $results = @()
      foreach ($ns in $namespaces) {
        $nsName = $ns.metadata.name
        $hasLimit = $limitRanges | Where-Object { $_.metadata.namespace -eq $nsName }
        if (-not $hasLimit) {
          $results += [pscustomobject]@{
            Namespace = $nsName
            Issue     = "‚ùå No LimitRange"
          }
        }
      }

      $results
    URL: "https://kubernetes.io/docs/concepts/policy/limit-range/"